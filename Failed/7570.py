# 23:42
# 
# n = 100만 -> log N 으로 끝내야한다
# 
# 한 번의 iterate로 답을 어떻게 구할까..?
#  - 자료구조를 활용하면 좋지 않을까? -> 해쉬맵, 스택, 큐, 힙
# 
# 1) 가장 작은 숫자부터 왼쪽으로 옯겨준다, 단 현대 자리가 내가 있어야하는 위치라면 pass
#
# 즉, iterate를 하면서 만약 그대로라면.. +1을 하지 않고 또 비교
# 
# 어떻게 하면 1,2,3 의 현재 자리를 기록할까?
#
# 혹은.. 오차순의 갯수를 보고.. 나머지만 판별..? 
#
#
# 해결책은.. 내가 있어야할 위치에서 가장 멀리있는거 부터 우선 옮겨준다
#
# 매게변수 탐색인가..? 
#
#
# 힙과, 큐를 동시에 사용한다
# -> 힙에서 거리를 순서로 pop해주고, 큐에서 최신화를 해준다
# 
# 1 2 3 4 5
# 3 0 2 1 4
# 
# -> 
# 5 = 2 4 1 3 5
# 1 = 1 2 4 3 5
# 
# 
# 현재 시점에서.. 왼쪽 오른쪽을.. 어떻게 정하지
#
# 사실 가장 안에 있어얄할 숫자부터 세우는게 맞을듯한데...
#
# 정렬되어 있는거.. = 1,3
# 정렬되어 있지 아는거 = 5,2,4
#
#


n = int(input())
l = list(map(int, input().split()))

compare = [a+1 for a in range(n)]

count = 0
start = 0
while start < len(l):
    
    


