# 10:02 ~ 10:59
#
# 입출력 : 100 -> 보통 DP가 100때가 많은거 같다 ..? 
# + 2^63-1인거를 보아 DP일 가능성이 높다는것을 판단할수 있다
# -> for 문은 그래도 여러개 사용가능
# 
# 접근법 : 
# 1) nxn DP를 만든다. 
# 2) 경로의 개수이니까 값을 더해주는게 아니라 그자리에 +1씩을 더해준다
# 3) 현재 칸에 있는 값에서 아래+옆에 그 값에 범위만큼 +1씩을 해준다
# 4) 만약 0에 도착하는 경로라면 총합에 더해준다


# 10:02
#
# 입출력 : 100 -> 보통 DP가 100때가 많은거 같다 ..? 
# + 2^63-1인거를 보아 DP일 가능성이 높다는것을 판단할수 있다
# -> for 문은 그래도 여러개 사용가능
# 
# 접근법 : 
# 1) nxn DP를 만든다. 
# 2) 경로의 개수이니까 값을 더해주는게 아니라 그자리에 +1씩을 더해준다
# 3) 현재 칸에 있는 값에서 아래+옆에 그 값에 범위만큼 +1씩을 해준다
# 4) 만약 0에 도착하는 경로라면 총합에 더해준다


n = int(input())
graph = []
for _ in range(n):
    graph.append(list(map(int, input().split())))

dp = [[0]*n for _ in range(n)]
dp[0][0] = 1


for a in range(n):
    for b in range(n):
        if a ==(n-1) and b == (n-1):
            break

        if b+graph[a][b] < n and dp[a][b] != 0:
            dp[a][b+graph[a][b]] += dp[a][b]
        
        if a+graph[a][b] < n and dp[a][b] != 0:
            dp[a+graph[a][b]][b] += dp[a][b] 
        

print(dp[n-1][n-1])